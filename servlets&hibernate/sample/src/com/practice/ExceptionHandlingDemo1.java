package com.practice;
/*
 * --CheckedException(higher failure rate)=>inherits the classes from Exception class
 * --UncheckedException(mostly programming mistakes)=>inherits the classes 
 * from RuntimeException 
 *  * --Error and all the subclasses are Unchecked exception
 *  */
/*
 * Checked Exception::	
--Checked exceptions occur at compile time.
--The compiler checks a checked exception.
--These types of exceptions can be handled at the time of compilation.
--They are the sub-class of the exception class.	
--Here, the JVM needs the exception to catch and handle.
--Examples of Checked exceptions:
**File Not Found Exception
**No Such Field Exception
**Interrupted Exception
**No Such Method Exception
**Class Not Found Exception

Unchecked Exception::
--Unchecked exceptions occur at runtime.
--The compiler does not check these types of exceptions.
--These types of exceptions cannot be a catch or handle at the time of compilation, 
because they get generated by the mistakes in the program.
--They are runtime exceptions and hence are not a part of the Exception class.
--Here, the JVM does not require the exception to catch and handle.
--Examples of Unchecked Exceptions:
**No Such Element Exception
**Undeclared Throwable Exception
**Empty Stack Exception
**Arithmetic Exception
**Null Pointer Exception
**Array Index Out of Bounds Exception
**Security Exception
 */
/*
 * | Feature                | **Checked Exception**                                  | **Unchecked Exception**                                                         |
| ---------------------- | ------------------------------------------------------ | ------------------------------------------------------------------------------- |
| **Type**               | **Compile-time exception**                             | **Runtime exception**                                                           |
| **Compiler checks?**   | ✅ Yes – Must be handled or declared                    | ❌ No – Not required to handle                                                   |
| **Extends**            | `Exception` (but **not** `RuntimeException`)           | `RuntimeException` (and its subclasses)                                         |
| **When it occurs?**    | During **compilation**                                 | During **program execution**                                                    |
| **Handling required?** | ✅ Must use `try-catch` or `throws`                     | ❌ Optional to handle                                                            |
| **Examples**           | `IOException`, `SQLException`, `FileNotFoundException` | `NullPointerException`, `ArithmeticException`, `ArrayIndexOutOfBoundsException` |

 */
public class ExceptionHandlingDemo1 {

	public static void main(String[] args) {
		//System.out.println("Divide:: "+(12/0));;//WITHOUT EXCEPTION HANDLING=>//NO COMPILATION ERROR BUT RUNTIME ERROR WILL COME=>LEADS TO ABNORMAL TERMINATION
		try
		{
			System.out.println("Divide:: "+(12/2));
			int a[]=new int[5];
			a[11]=57050;//size out of bounds
		}
		catch(Throwable e)//super class for all exception classes! valid! handle all the issues!
		//	catch(Exception e)//Common exception class! handle all the issues!
		//catch(ArithmeticException e)//specific exception to he handled
		{
			System.out.println("Division By Zero issue!!!");
			System.out.println("Exception object:: "+e);//e.toString()
			System.out.println("Exception error message:: "+e.getMessage());
		}
		//optional block
		//finally block always get executed! both success and failure scenarios!
		//The finally block is used to guarantee cleanup, like closing files or releasing resources, regardless of success or failure in the try block.
		finally//similar to static block
		{
			System.out.println("Finally Block:: DB Connection Close(),IO File Close(),signout()");
		}
		System.out.println("Program continues normally...!!!");	

	}

}
